
# Top K Frequent Elements and Priority Queues in Python

## Context Clarification

The problem of finding the **top K most frequent elements** is a common interview and competitive programming question. Efficient solutions often rely on **hashmaps** for counting and **heaps (priority queues)** for extracting the most frequent items.  
This note explores different approaches (insertion sort, heaps, bucket sort), explains the complexity trade-offs, and clarifies how `heapq` handles ordering.

---

## Step 1: Counting Frequencies

We first count element occurrences using a hashmap:

```python
from collections import defaultdict

freq = defaultdict(int)
for num in nums:
    freq[num] += 1
```

- Complexity: `O(n)` for `n` elements.
    
- `freq` maps element → occurrence count.
    

---

## Approach 1: Insertion Sort on a Size-K Array

Idea:

1. Build frequency hashmap.
    
2. Keep a sorted list of the top K elements using insertion sort.
    

### Complexity

- Counting: `O(n)`
    
- Insertion into a sorted array of size K: `O(K)` per unique element
    
- Overall: `O(n + m*K)` where `m` = number of unique elements
    

### When is this good?

- Works fine if `K` is small compared to `m`.
    
- Inefficient if `K` is large, since insertion sort has `O(K²)` behavior in the worst case.
    

---

## Step 2: Understanding Priority Queues (`heapq`)

### Basics

- Python’s `heapq` implements a **min-heap**.
    
- `heapq.heappush(heap, item)` → pushes with `O(log n)`
    
- `heapq.heappop(heap)` → pops smallest with `O(log n)`
    

### Why does it pick `priority`?

If you push a tuple `(priority, count, task)`, Python uses **tuple comparison**:

1. Compare first element (priority).
    
2. If tied, compare second element (count).
    
3. If still tied, compare third (task).
    

This is why the **first item in the tuple is always the priority**.  
The `count` is often included to break ties safely.

---

## Approach 2: Min-Heap of Size K

Instead of sorting all frequencies:

1. Push `(frequency, element)` into a heap.
    
2. Keep the heap size ≤ K (pop smallest if it grows).
    
3. Result = the heap contents.
    

### Complexity

- Counting: `O(n)`
    
- Heap operations: `O(m log K)`
    
- Total: `O(n + m log K)`
    

### When is this good?

- Very efficient if `K` is small compared to `m`.
    

---

## Approach 3: Bucket Sort

1. Group elements by frequency into “buckets.”
    
2. Traverse buckets from high to low until K elements are collected.
    

### Complexity

- Counting: `O(n)`
    
- Bucket creation and scan: `O(n)`
    
- Total: `O(n)`
    

### When is this good?

- Very fast when frequencies are bounded and `n` is not massive.
    
- Uses extra memory proportional to `n`.
    

---

 When you start putting **complex objects** into a priority queue, Python’s `heapq` won’t “guess” which field should be used for ordering — you have to explicitly tell it by wrapping your object in a **tuple** or by defining a custom comparison.

---

### Example 1: Using a tuple for priority

Imagine you have sensor readings with **temperature** and some metadata. If you want the heap to prioritize by temperature:

```python
import heapq

class Reading:
    def __init__(self, temperature, sensor_id):
        self.temperature = temperature
        self.sensor_id = sensor_id

    def __repr__(self):
        return f"Sensor {self.sensor_id}: {self.temperature}°C"

pq = []

# push items: (priority, object)
heapq.heappush(pq, (25, Reading(25, "A")))
heapq.heappush(pq, (30, Reading(30, "B")))
heapq.heappush(pq, (20, Reading(20, "C")))

# pop items ordered by temperature
while pq:
    temp, reading = heapq.heappop(pq)
    print(temp, reading)
```

Here the **first element of the tuple (`25`, `30`, `20`)** is what the heap uses to order items. You’ve made temperature the explicit priority.

---

### Example 2: Prioritize by temperature without tuple wrapping

If you want the object itself to carry the comparison logic, you can define ordering methods like `__lt__` (less than):

```python
import heapq

class Reading:
    def __init__(self, temperature, sensor_id):
        self.temperature = temperature
        self.sensor_id = sensor_id

    def __lt__(self, other):
        # order by temperature
        return self.temperature < other.temperature

    def __repr__(self):
        return f"Sensor {self.sensor_id}: {self.temperature}°C"

pq = []
heapq.heappush(pq, Reading(25, "A"))
heapq.heappush(pq, Reading(30, "B"))
heapq.heappush(pq, Reading(20, "C"))

while pq:
    print(heapq.heappop(pq))
```

Now `heapq` knows how to compare two `Reading` objects because you defined `__lt__`.

---

### Rule of Thumb

- If your object has **one clear priority field** (like temperature), just use a tuple `(temperature, obj)`.
    
- If your object will **always** be ordered the same way, define `__lt__`.
    
- If you need to break ties (same temperature but different timestamps), use a tuple with multiple fields, e.g. `(temperature, timestamp, obj)`.
    

---
## Using `heapq.nlargest` with `key`

Python gives a shortcut:

```python
import heapq

heapq.nlargest(k, freq.keys(), key=freq.get)
```

### Why this works

- `freq.keys()` are the unique elements.
    
- `key=freq.get` ranks each element by its frequency value.
    
- Internally optimized to run in `O(n log K)`.
    

---

## Common Mistakes

|Code|What it does|Correct?|
|---|---|---|
|`heapq.nlargest(k, freq.keys())`|Returns numerically largest keys|❌|
|`heapq.nlargest(k, freq.values())`|Returns top counts, loses mapping|❌|
|`heapq.nlargest(k, freq.keys(), key=freq.get)`|Returns elements by frequency|✅|

---

## Final Code Example

```python
import heapq
from collections import defaultdict

def topKFrequent(nums, k):
    freq = defaultdict(int)
    for num in nums:
        freq[num] += 1
    return heapq.nlargest(k, freq.keys(), key=freq.get)
```

- Builds frequency hashmap in `O(n)`.
    
- Finds top K frequent elements in `O(m log K)`.
    

---

## Summary of Approaches

- **Insertion sort array of size K** → `O(m*K)`, fine for small K.
    
- **Heap (priority queue)** → `O(n + m log K)`, scalable.
    
- **Bucket sort** → `O(n)`, optimal but with more memory tradeoffs.
    
- **heapq.nlargest with key** → clean, Pythonic, efficient.


#leetcode347 #leetcode